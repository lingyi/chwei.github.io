###C++纯虚函数

来自群里讨论的一个关于虚函数的讨论。

> xxx 2017-03-06 11:17:58

> 2. 关于C++中类的继承和多态概念正确选项是？【中等】（）

> A. 基类中声明了一个纯虚函数，说明该基类是一个抽象基类。

> B. 纯虚函数是交给派生类以实现多态性质，所以基类不能实现它声明的这个纯虚函数。

> C. 如果派生类对象调用它定义的默认构造函数进行构造，它会自动调用其基类默认构造函数构造对象的基类部分

> D. 无论基类的析构函数是否声明为virtual函数，派生类对象析构时都会自动调用的基类构造函数 


涉及几个点：

（1）纯虚函数的定义？抽象类的定义？

（2）纯虚函数是否可以有定义？

纯虚函数也可以定义，但不能在类内声明的时候定义，要在类外定义。
参见[这里](http://www.programmerinterview.com/index.php/c-cplusplus/pure-virtual-function/)

（3）C. 如果派生类对象调用它定义的默认构造函数进行构造，它会自动调用其基类默认构造函数构造对象的基类部分

不准确。派生类会自动调用基类的构造函数，但不一定是基类默认构造函数。无参默认构造函数和带默认值的构造函数会存在二义性。

（4）D. 无论基类的析构函数是否声明为virtual函数，派生类对象析构时都会自动调用的基类构造函数。

字面意思没有错误，但是要注意的两个陷阱。这个分几种情况，（a）指向派生类对象的是基类指针，若基类析构函数不声明为virtual函数，则这时候析构派生类对象时只会调用基类的析构函数。若基类析构函数声明为virtual函数，delete指向派生类对象的是基类指针时会同时调用派生类和基类的析构函数。 （b）指向派生类对象的是派生类指针，这时候基类析构函数是否声明为virtual，派生类对象析构时都能正常调用派生类和基类的析构函数。

简单示例代码：

```C++

  7 class Base
  8 {
  9 public:
 10     Base()
 11     {
 12          cout << "Base()" << endl;
 13     }
 14 
 15     //Base(int a = 0) {}
 16 
 17     //virtual 
 18     ~Base()
 19     {
 20          cout << "~Base()" << endl;
 21     }
 22 
 23     virtual void fun() = 0;
 24 };
 25 
 26 void Base::fun()
 27 {
 28     cout << "Base::fun()" << endl;
 29 }
 30 
 31 class A : public Base
 32 {
 33 public:
 34     A() {cout << "A()" << endl;}
 35     //virtual 
 36     ~A() {cout << "~A()" << endl;}
 37 
 38     virtual void fun()
 39     {
 40         cout << "A:fun()" << endl;
 41     }
 42 };
 43 
 44 int main()
 45 {
 46     //Base *a = new A();    
 47     A *a = new A();
 48     a->fun();
 49 
 50     //free(a);
 51     delete a;
 52 }
```
